=== tests/cases/compiler/typeCall.ts ===
type F1 = () => 1;
>F1 : F1

type a = F1();
>a : 1
>F1 : F1

type F2 = (a: string) => 1;
>F2 : F2
>a : string

type b = F2('foo');
>b : 1
>F2 : F2

interface F3 {
>F3 : F3

    (): 1;
    (a: number): 2;
>a : number

    (a: string): 3;
>a : string
}
type c = F3();
>c : 1
>F3 : F3

type d = F3(123);
>d : 2
>F3 : F3

type e = F3('foo');
>e : 3
>F3 : F3

declare function f4(a: string): 1;
>f4 : (a: string) => 1
>a : string

let a = 'foo';
>a : string
>'foo' : "foo"

type f = typeof f4(typeof a);
>f : 1
>f4 : (a: string) => 1
>a : string

type g = (() => 1)();
>g : 1

type Id = <T>(v: T) => T;
>Id : Id
>T : T
>v : T
>T : T
>T : T

type h = Id(123);
>h : 123
>Id : Id

type Wrap<T> = Id(T);
>Wrap : Id(T)
>T : T
>Id : Id
>T : T

type i = Wrap<123>;
>i : Id(T)
>Wrap : Id(T)

type F5 = () => () => { a: () => 1; };
>F5 : F5
>a : () => 1

type j = F5()()['a']();
>j : 1
>F5 : F5

// type k1 = Id<string>('foo');
// ^ errors, `<string>` is part of the type reference, not the function call
type k2 = Id<><string>('foo'); // ok, `string`
>k2 : "foo"
>Id : Id

declare function id<T>(v: T): T;
>id : <T>(v: T) => T
>T : T
>v : T
>T : T
>T : T

let l = id<string>('foo');
>l : string
>id<string>('foo') : string
>id : <T>(v: T) => T
>'foo' : "foo"

interface IsPrimitive {
>IsPrimitive : IsPrimitive

  (o: object): '0';
>o : object

  (o: any): '1';
>o : any
}
type stringIsPrimitive = IsPrimitive(string); // '1', ok
>stringIsPrimitive : "1"
>IsPrimitive : IsPrimitive

type regexpIsPrimitive = IsPrimitive(RegExp); // '0', ok
>regexpIsPrimitive : "0"
>IsPrimitive : IsPrimitive
>RegExp : RegExp

// explicit type arguments need to go after the type arguments of the type reference, empty `<>` if n/a
type genericIsPrimitive = <T>() => IsPrimitive(T);
>genericIsPrimitive : genericIsPrimitive
>T : T
>IsPrimitive : IsPrimitive
>T : T

type stringIsPrimitive2 = genericIsPrimitive<><string>(); // '1', ok
>stringIsPrimitive2 : IsPrimitive(T)
>genericIsPrimitive : genericIsPrimitive

type regexpIsPrimitive2 = genericIsPrimitive<><RegExp>();
>regexpIsPrimitive2 : IsPrimitive(T)
>genericIsPrimitive : genericIsPrimitive

// fails, see #17471, '1' instead of '0', should delay overload selection until type argument is known

// alternative, pass as parameters
type genericIsPrimitive3 = <T>(v: T) => IsPrimitive(T);
>genericIsPrimitive3 : genericIsPrimitive3
>T : T
>v : T
>T : T
>IsPrimitive : IsPrimitive
>T : T

type stringIsPrimitive3 = genericIsPrimitive3(string); // '1', ok
>stringIsPrimitive3 : IsPrimitive(T)
>genericIsPrimitive3 : genericIsPrimitive3

type regexpIsPrimitive3 = genericIsPrimitive3(RegExp)
>regexpIsPrimitive3 : IsPrimitive(T)
>genericIsPrimitive3 : genericIsPrimitive3
>RegExp : RegExp

// fails, see #17471, '1' instead of '0', should delay overload selection until type argument is known

type map = <Fn extends (v: T) => any, O extends { [k: string]: T }, T>(fn: Fn, obj: O) => { [P in keyof O]: Fn(O[P]) };
>map : map
>Fn : Fn
>v : T
>T : T
>O : O
>k : string
>T : T
>T : T
>fn : Fn
>Fn : Fn
>obj : O
>O : O
>P : P
>O : O
>Fn : Fn
>O : O
>P : P

type z = map(<T>(v: T) => [T], { a: 1, b: 2, c: 3 });
>z : { a: (<T>(v: T) => [T])(O[P]); b: (<T>(v: T) => [T])(O[P]); c: (<T>(v: T) => [T])(O[P]); }
>map : map
>T : T
>v : T
>T : T
>T : T
>a : 1
>b : 2
>c : 3

// FAILS!, wanted `{ a: [1], b: [2], c: [3] }`, got `{ a: any; b: any; c: any; }`.

// binary function composition
type Fn1 = <T1 extends number>(v1: T1[]) => { [k: string]: T1 };
>Fn1 : Fn1
>T1 : T1
>v1 : T1[]
>T1 : T1
>k : string
>T1 : T1

type Fn2 = <T2>(v2: { [k: string]: T2 }) => ReadonlyArray<T2>;
>Fn2 : Fn2
>T2 : T2
>v2 : { [k: string]: T2; }
>k : string
>T2 : T2
>ReadonlyArray : ReadonlyArray<T>
>T2 : T2

let fn1 = null! as Fn1;
>fn1 : Fn1
>null! as Fn1 : Fn1
>null! : never
>null : null
>Fn1 : Fn1

let fn2 = null! as Fn2;
>fn2 : Fn2
>null! as Fn2 : Fn2
>null! : never
>null : null
>Fn2 : Fn2

type Fn3 = <T3 extends number[]>(v3: T3) => Fn2(Fn1(T3));
>Fn3 : Fn3
>T3 : T3
>v3 : T3
>T3 : T3
>Fn2 : Fn2
>Fn1 : Fn1
>T3 : T3

// type Fn4 = Fn3(1); // errors, ok
let ones = null! as 1[];
>ones : 1[]
>null! as 1[] : 1[]
>null! : never
>null : null

type Fn4b = Fn3(typeof ones);
>Fn4b : Fn2(Fn1(T3))
>Fn3 : Fn3
>ones : 1[]

// FAILS, wanted `ReadonlyArray<1>`, got `ReadonlyArray<number>`.
type Fn4c = Fn3(1[]);
>Fn4c : Fn2(Fn1(T3))
>Fn3 : Fn3

// FAILS, wanted `ReadonlyArray<1>`, got `ReadonlyArray<number>`.
// let x = fn2(fn1(1)); // errors with not assignable, ok
// type X = Fn2(Fn1(1)); // errors with not assignable, ok
let y = fn2(fn1(ones));
>y : ReadonlyArray<1>
>fn2(fn1(ones)) : ReadonlyArray<1>
>fn2 : Fn2
>fn1(ones) : { [k: string]: 1; }
>fn1 : Fn1
>ones : 1[]

type Y = Fn2(Fn1(1[]));
>Y : ReadonlyArray<1>
>Fn2 : Fn2
>Fn1 : Fn1

type IndexCall<T extends () => { [k: string]: any }, K extends keyof (T())> = T()[K];
>IndexCall : T()[K]
>T : T
>k : string
>K : K
>T : T
>T : T
>K : K

type CallMember<T extends { [k: string]: () => any }, K extends keyof T> = T[K]();
>CallMember : T[K]()
>T : T
>k : string
>K : K
>T : T
>T : T
>K : K

type MappedMemberCall<T extends { [k: string]: () => any }> = { [K in keyof T]: T[K]() };
>MappedMemberCall : MappedMemberCall<T>
>T : T
>k : string
>K : K
>T : T
>T : T
>K : K

type HasKey<T, Key extends string> = (
>HasKey : ({ [K in keyof T]: "true"; } & { [key: string]: "false"; })[Key]
>T : T
>Key : Key

  { [K in keyof T]: 'true' } &
>K : K
>T : T

  { [key: string]: 'false' }
>key : string

)[Key];
>Key : Key

type HasKindKey<T extends () => any> = HasKey<T(), 'kind'>;
>HasKindKey : ({ [K in keyof T]: "true"; } & { [key: string]: "false"; })["kind"]
>T : T
>HasKey : ({ [K in keyof T]: "true"; } & { [key: string]: "false"; })[Key]
>T : T

type MapHasKey<T extends { [k: string]: () => any }, Key extends string> = {
>MapHasKey : MapHasKey<T, Key>
>T : T
>k : string
>Key : Key

    [K in keyof T]: HasKey<T[K](), Key>
>K : K
>T : T
>HasKey : ({ [K in keyof T]: "true"; } & { [key: string]: "false"; })[Key]
>T : T
>K : K
>Key : Key

};

type KeyOfCall<T extends () => any> = keyof (T());
>KeyOfCall : keyof T()
>T : T
>T : T

type Strip1<T extends () => any> = { [K in keyof (T())]: T()[K] };
>Strip1 : Strip1<T>
>T : T
>K : K
>T : T
>T : T
>K : K

type Strip2<T extends () => { [k: string]: () => any }> = { [K in keyof (T())]: T()[K]() };
>Strip2 : Strip2<T>
>T : T
>k : string
>K : K
>T : T
>T : T
>K : K

type Obj = {
>Obj : Obj

    x: () => number,
>x : () => number

    z: () => { kind: 'Just', value: string }
>z : () => { kind: "Just"; value: string; }
>kind : "Just"
>value : string
}

type T1 = (() => number)();
>T1 : number

type T7 = CallMember<Obj, 'x'>;
>T7 : number
>CallMember : T[K]()
>Obj : Obj

type T8 = IndexCall<() => Obj, 'x'>;
>T8 : () => number
>IndexCall : T()[K]
>Obj : Obj

type T9 = MappedMemberCall<Obj>; // fails, unresolved, want { x: number, z: { kind: 'Just', value: string } }
>T9 : MappedMemberCall<Obj>
>MappedMemberCall : MappedMemberCall<T>
>Obj : Obj

type T13 = keyof (() => Obj)();
>T13 : "x" | "z"
>Obj : Obj

type T14 = KeyOfCall<() => Obj>;
>T14 : "x" | "z"
>KeyOfCall : keyof T()
>Obj : Obj

type T15 = Obj['z']()['kind'];
>T15 : "Just"
>Obj : Obj

type T16 = MapHasKey<Obj, 'kind'>; // fails, unresolved, want { x: 'false', z: 'true' }
>T16 : MapHasKey<Obj, "kind">
>MapHasKey : MapHasKey<T, Key>
>Obj : Obj

type T17 = Strip1<() => Obj>; // fails, unresolved, want { x: () => number, z: () => { kind: 'Just', value: string } }
>T17 : Strip1<() => Obj>
>Strip1 : Strip1<T>
>Obj : Obj

type T19 = Strip2<() => Obj>; // fails, unresolved, want { x: number, z: { kind: 'Just', value: string } }
>T19 : Strip2<() => Obj>
>Strip2 : Strip2<T>
>Obj : Obj

let a1: () => string;
>a1 : () => string

let b1: typeof a1();
>b1 : string
>a1 : () => string

type Assert<T extends () => any> = T();
>Assert : T()
>T : T
>T : T

let c1: Assert<typeof a1>;
>c1 : string
>Assert : T()
>a1 : () => string

declare function infer1<T extends () => any>(x: T): T();
>infer1 : <T extends () => any>(x: T) => T()
>T : T
>x : T
>T : T
>T : T

infer1(null! as () => number);
>infer1(null! as () => number) : number
>infer1 : <T extends () => any>(x: T) => T()
>null! as () => number : () => number
>null! : never
>null : null

declare function infer2<T extends () => any>(x: { a: T }): T();
>infer2 : <T extends () => any>(x: { a: T; }) => T()
>T : T
>x : { a: T; }
>a : T
>T : T
>T : T

infer2(null! as { a: () => number });
>infer2(null! as { a: () => number }) : number
>infer2 : <T extends () => any>(x: { a: T; }) => T()
>null! as { a: () => number } : { a: () => number; }
>null! : never
>null : null
>a : () => number

declare function infer3<T>(x: { a: () => T }): T;
>infer3 : <T>(x: { a: () => T; }) => T
>T : T
>x : { a: () => T; }
>a : () => T
>T : T
>T : T

infer3(null! as { a: () => number });
>infer3(null! as { a: () => number }) : number
>infer3 : <T>(x: { a: () => T; }) => T
>null! as { a: () => number } : { a: () => number; }
>null! : never
>null : null
>a : () => number

const res3: number = infer3(null! as { a: () => number });
>res3 : number
>infer3(null! as { a: () => number }) : number
>infer3 : <T>(x: { a: () => T; }) => T
>null! as { a: () => number } : { a: () => number; }
>null! : never
>null : null
>a : () => number

declare function infer4<T>(x: T, y: () => T): void;
>infer4 : <T>(x: T, y: () => T) => void
>T : T
>x : T
>T : T
>y : () => T
>T : T

infer4(5, () => 5);
>infer4(5, () => 5) : void
>infer4 : <T>(x: T, y: () => T) => void
>5 : 5
>() => 5 : () => number
>5 : 5

function assignability<T>(x: T, y: () => T) {
>assignability : <T>(x: T, y: () => T) => void
>T : T
>x : T
>T : T
>y : () => T
>T : T

    const a: T = x;
>a : T
>T : T
>x : T

    const b: T = y();
>b : T
>T : T
>y() : T
>y : () => T
}

function comparability<T>(x: T, y: () => T) {
>comparability : <T>(x: T, y: () => T) => void
>T : T
>x : T
>T : T
>y : () => T
>T : T

    x === x;
>x === x : boolean
>x : T
>x : T

    y === y;
>y === y : boolean
>y : () => T
>y : () => T

    // x === y; // rightfully errors
}

// function mappedAssignability<T>(x: T, y: CallMember<T>) {
//     const d: T() = y;
// }

// function mappedComparability<T>(x: T, y: CallMember<T>) {
//     x === x;
//     y === y;
//     x === y;
// }

// type IdMapped<T> = { [K in keyof T]: T[K] }

// function mappedRelations<T>(x: IdMapped<T>, y: Partial<T>, z: CallMember<T>) {
//     x === z;
//     y === z;

//     const a: IdMapped<T> = z;
//     const b: Partial<T> = z;
// }

// mappedRelations(null! as Obj, null! as Partial<Obj>, null! as CallMember<Obj>);
// mappedRelations(null! as CallMember<Obj>, null! as CallMember<Obj>, null! as CallMember<Obj>);

