tests/cases/compiler/typeCall.ts(14,13): error TS2345: Argument of type '"foo"' is not assignable to parameter of type 'number'.
tests/cases/compiler/typeCall.ts(35,38): error TS2345: Argument of type 'string' is not assignable to parameter of type 'object'.
tests/cases/compiler/typeCall.ts(39,41): error TS2345: Argument of type 'string' is not assignable to parameter of type 'object'.
tests/cases/compiler/typeCall.ts(52,29): error TS2345: Argument of type 'true' is not assignable to parameter of type 'false'.
tests/cases/compiler/typeCall.ts(54,31): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false & true'.
tests/cases/compiler/typeCall.ts(54,31): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false'.
tests/cases/compiler/typeCall.ts(54,31): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'true'.
tests/cases/compiler/typeCall.ts(55,29): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false & true'.
tests/cases/compiler/typeCall.ts(55,29): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false'.
tests/cases/compiler/typeCall.ts(55,29): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'true'.
tests/cases/compiler/typeCall.ts(56,28): error TS2345: Argument of type 'any' is not assignable to parameter of type 'boolean'.
tests/cases/compiler/typeCall.ts(56,28): error TS2345: Argument of type 'any' is not assignable to parameter of type 'false & true'.
  Type 'any' is not assignable to type 'false'.
tests/cases/compiler/typeCall.ts(56,28): error TS2345: Argument of type 'any' is not assignable to parameter of type 'false'.
tests/cases/compiler/typeCall.ts(56,28): error TS2345: Argument of type 'any' is not assignable to parameter of type 'true'.
tests/cases/compiler/typeCall.ts(101,166): error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
tests/cases/compiler/typeCall.ts(101,166): error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
  Property 'length' is missing in type '{}'.
tests/cases/compiler/typeCall.ts(102,167): error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
tests/cases/compiler/typeCall.ts(103,169): error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
tests/cases/compiler/typeCall.ts(106,170): error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
tests/cases/compiler/typeCall.ts(119,22): error TS2345: Argument of type 'Fn2' is not assignable to parameter of type '<T>(v: T) => any'.
tests/cases/compiler/typeCall.ts(119,22): error TS2345: Argument of type 'Fn2' is not assignable to parameter of type '<T>(v: T) => any'.
  Types of parameters 'v2' and 'v' are incompatible.
    Type 'T' is not assignable to type '{ [k: string]: {}; }'.
tests/cases/compiler/typeCall.ts(120,13): error TS2346: Call target does not contain any signatures.
tests/cases/compiler/typeCall.ts(134,23): error TS2345: Argument of type 'false' is not assignable to parameter of type 'never'.
tests/cases/compiler/typeCall.ts(135,22): error TS2345: Argument of type 'true' is not assignable to parameter of type 'never'.
tests/cases/compiler/typeCall.ts(136,21): error TS2345: Argument of type 'string' is not assignable to parameter of type 'boolean'.
tests/cases/compiler/typeCall.ts(136,21): error TS2345: Argument of type 'string' is not assignable to parameter of type 'never'.
tests/cases/compiler/typeCall.ts(137,21): error TS2345: Argument of type 'any' is not assignable to parameter of type 'boolean'.
tests/cases/compiler/typeCall.ts(137,21): error TS2345: Argument of type 'any' is not assignable to parameter of type 'never'.
tests/cases/compiler/typeCall.ts(140,18): error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'null | undefined'.
  Type 'string' is not assignable to type 'null | undefined'.
tests/cases/compiler/typeCall.ts(146,20): error TS2345: Argument of type 'string | number' is not assignable to parameter of type 'number'.
  Type 'string' is not assignable to type 'number'.
tests/cases/compiler/typeCall.ts(153,27): error TS2345: Argument of type 'string' is not assignable to parameter of type 'PromiseLike<{}>'.
tests/cases/compiler/typeCall.ts(153,27): error TS2345: Argument of type '{}' is not assignable to parameter of type 'PromiseLike<{}>'.
  Property 'then' is missing in type '{}'.
tests/cases/compiler/typeCall.ts(156,42): error TS2345: Argument of type 'string' is not assignable to parameter of type 'PromiseLike<{}>'.
tests/cases/compiler/typeCall.ts(158,42): error TS2345: Argument of type 'boolean | Promise<string>' is not assignable to parameter of type 'PromiseLike<string>'.
  Type 'true' is not assignable to type 'PromiseLike<string>'.
tests/cases/compiler/typeCall.ts(163,42): error TS2345: Argument of type 'number | Promise<boolean>' is not assignable to parameter of type 'PromiseLike<boolean>'.
  Type 'number' is not assignable to type 'PromiseLike<boolean>'.
tests/cases/compiler/typeCall.ts(173,16): error TS2345: Argument of type 'any' is not assignable to parameter of type 'PromiseLike<{}>'.
tests/cases/compiler/typeCall.ts(173,16): error TS2345: Argument of type 'number | Promise<string>' is not assignable to parameter of type 'PromiseLike<string>'.
  Type 'number' is not assignable to type 'PromiseLike<string>'.
tests/cases/compiler/typeCall.ts(173,42): error TS2345: Argument of type 'any' is not assignable to parameter of type 'PromiseLike<{}>'.


==== tests/cases/compiler/typeCall.ts (38 errors) ====
    type F1 = () => 1;
    type a = F1();
    
    type F2 = (a: string) => 1;
    type b = F2('foo');
    
    interface F3 {
        (): 1;
        (a: number): 2;
        (a: string): 3;
    }
    type c = F3();
    type d = F3(123);
    type e = F3('foo');
                ~~~~~
!!! error TS2345: Argument of type '"foo"' is not assignable to parameter of type 'number'.
    
    declare function f4(a: string): 1;
    let a = 'foo';
    type f = typeof f4(typeof a);
    
    type g = (() => 1)();
    
    type Id = <T>(v: T) => T;
    type h = Id(123);
    
    type Wrap<T> = Id(T);
    type i = Wrap<123>;
    
    type F5 = () => () => { a: () => 1; };
    type j = F5()()['a']();
    
    interface IsPrimitive {
      (o: object): '0';
      (o: any): '1';
    }
    type stringIsPrimitive = IsPrimitive(string);
                                         ~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'object'.
    type regexpIsPrimitive = IsPrimitive(RegExp);
    
    // alternative, pass as parameters
    type genericIsPrimitive3 = <T>(v: T) => IsPrimitive(T);
                                            ~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'object'.
    type stringIsPrimitive3 = genericIsPrimitive3(string);
    type regexpIsPrimitive3 = genericIsPrimitive3(RegExp)
    
    declare function angularFactory<G extends (...args: any[]) => R, R extends <T>(foo: T) => T[]>(g: G): R(123);
    angularFactory((...args: any[]) => <T>(foo: T) => [foo] as [T])
    
    interface BoolToString {
        (v: false & true): never;
        (v: false): 'false';
        (v: true): 'true';
        (v: boolean): 'true' | 'false';
    }
    type strTrue = BoolToString(true);
                                ~~~~
!!! error TS2345: Argument of type 'true' is not assignable to parameter of type 'false'.
    type strFalse = BoolToString(false);
    type strEither = BoolToString(true | false);
                                  ~~~~~~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false & true'.
                                  ~~~~~~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false'.
                                  ~~~~~~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'true'.
    type strBool = BoolToString(boolean);
                                ~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false & true'.
                                ~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'false'.
                                ~~~~~~~
!!! error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'true'.
    type strAny = BoolToString(any); // fails, want the fallback, but yields 'false'
                               ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'boolean'.
                               ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'false & true'.
!!! error TS2345:   Type 'any' is not assignable to type 'false'.
                               ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'false'.
                               ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'true'.
    
    type map = <Fn extends (v: T) => any, O extends { [k: string]: T }, T>(fn: Fn, obj: O) => { [P in keyof O]: Fn(O[P]) };
    type z = map(<T>(v: T) => [T], { a: 1, b: 2, c: 3 });
    declare function map<Fn extends <T>(v: T) => any, O extends { [k: string]: T }, T>(fn: Fn, obj: O): { [P in keyof O]: Fn(O[P]) };
    let z = map(<T>(v: T) => [v] as [T], { a: 1, b: 2, c: 3 } as { a: 1, b: 2, c: 3 });
    
    type Inc = { [k: string]: string; 0:'1', 1:'2', 2:'3', 3:'4', 4:'5', 5:'6', 6:'7', 7:'8', 8:'9' };
    type StringToNumber = { [k: string]: number; 0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8};
    type TupleHasIndex<Arr extends any[], I extends string> = ({[K in keyof Arr]: '1' } & { [k: string]: '0' })[I];
    type PathFn<T extends { [k: string]: any }, R extends Array<string>, I extends string = '0'> =
        { 1: PathFn<T[R[StringToNumber[I]]], R, Inc[I]>, 0: T }[TupleHasIndex<R, I>];
    type PathTest = PathFn<{ a: { b: ['c', { d: 'e' }] } }, ['a', 'b', '1', 'd']>;
    declare function path<T extends { [k: string]: any }, R extends Array<string>>(obj: T, path: R): PathFn<T, R>;
    const obj = null! as { a: { b: ['c', { d: 'e' }] } };
    const keys = null! as ['a', 'b', '1', 'd'];
    const pathTest = path(obj, keys);
    // "e"
    
    // type Reduce<
    //     Fn extends (previousValue: T, currentValue: R[number], currentIndex?: number, array?: R) => any,
    //     T,
    //     R extends any[],
    //     I extends string = '0'
    // > = { 1: Reduce<Fn(T, R[StringToNumber[I]], I, R), R, Inc[I]>, 0: T }[TupleHasIndex<R, I>];
    // // fails with error: Cannot read property 'flags' of undefined
    // declare function reduce<
    //     Fn extends (previousValue: any, currentValue: R[number], currentIndex?: number, array?: R) => any,
    //     R extends any[],
    //     U,
    //     I extends string = '0'
    // >(callbackfn: Fn, initialValue: U, array: R): Reduce<Fn, U, R>;
    // declare function path2<T extends { [k: string]: any }, R extends Array<string>>(obj: T, path: R):
    //     Reduce<<Prev, Curr>(previousValue: Prev, currentValue: Curr, currentIndex?: number, array?: any[]) => Prev[Curr], T, R>;
    // const pathTest2 = path2(obj, keys);
    // // "e"
    
    // binary function composition
    type Fn1 = <T1 extends number>(v1: T1[]) => { [k: string]: T1 };
    type Fn2 = <T2>(v2: { [k: string]: T2 }) => ReadonlyArray<T2>;
    let fn1 = null! as Fn1;
    let fn2 = null! as Fn2;
    type Param1 = <Fun extends (v1: T) => any, T>(f: Fun) => T;
    type Par1 = Param1(Fn1);
    // type Fn3 = <T3 extends number[]>(v3: T3) => Fn2(Fn1(T3));
    type Pipe1 = <Fun1 extends <U>(/*...args: any[]*/ p1: P1) => T, Fun2 extends <U>(v: T) => any, P1, T>(fun1: Fun1, fun2: Fun2) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
                                                                                                                                                                         ~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
                                                                                                                                                                         ~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
!!! error TS2345:   Property 'length' is missing in type '{}'.
    type Pipe4 = <Fun1 extends <U>(/*...args: any[]*/ p1: P1) => any, Fun2 extends <T>(v: any) => any, P1>(fun1: Fun1, fun2: Fun2) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
                                                                                                                                                                          ~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
    type Compose1 = <Fun2 extends <U>(v: T) => any, Fun1 extends <U>(/*...args: any[]*/ p1: P1) => T, P1, T>(fun2: Fun2, fun1: Fun1) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
                                                                                                                                                                            ~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
    // type Compose2 = <Fun2 extends <T>(v: T) => any, Fun1 extends <U>(/*...args: any[]*/ p1: P1) => T, P1>(fun2: Fun2, fun1: Fun1) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
    type Compose3 = <Fun2 extends <T>(v: T) => any, Fun1 extends <U>(/*...args: any[]*/ p1: P1) => any, P1>(fun2: Fun2, fun1: Fun1) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
    type Compose4 = <Fun2 extends <T>(v: any) => any, Fun1 extends <U>(/*...args: any[]*/ p1: P1) => any, P1>(fun2: Fun2, fun1: Fun1) => (/*...args: any[]*/ p1: P1) => Fun2(Fun1(P1));
                                                                                                                                                                             ~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'number[]'.
    // declare function fn3<Fun1 extends <P1>(/*...args: any[]*/ p1: P1) => T, Fun2 extends <P2>(v: T) => any, P1, T>(fun1: Fun1, fun2: Fun2): (...args: any[] /* todo: specify*/) => Fn2(Fn1(P1));
    let ones = null! as 1[];
    // type Fn4b = Fn3(typeof ones);
    // type Fn4c = Fn3(1[]);
    type Fn3d = Pipe1(Fn1, Fn2);
    type Fn4d = Fn3d(1[]);
    type Fn3i = Pipe4(Fn1, Fn2);
    type Fn4i = Fn3i(1[]);
    type Fn3e = Compose1(Fn2, Fn1);
    type Fn4e = Fn3e(1[]);
    // type Fn3f = Compose2(Fn2, Fn1);
    // type Fn4f = Fn3f(1[]);
    type Fn3g = Compose3(Fn2, Fn1);
                         ~~~
!!! error TS2345: Argument of type 'Fn2' is not assignable to parameter of type '<T>(v: T) => any'.
                         ~~~
!!! error TS2345: Argument of type 'Fn2' is not assignable to parameter of type '<T>(v: T) => any'.
!!! error TS2345:   Types of parameters 'v2' and 'v' are incompatible.
!!! error TS2345:     Type 'T' is not assignable to type '{ [k: string]: {}; }'.
    type Fn4g = Fn3g(1[]);
                ~~~~~~~~~
!!! error TS2346: Call target does not contain any signatures.
    type Fn3h = Compose4(Fn2, Fn1);
    type Fn4h = Fn3h(1[]);
    // let y = fn2(fn1(ones));
    // type Y = Fn2(Fn1(1[]));
    // let z2 = fn3(fn1, fn2)(ones); // Cannot read property 'parent' of undefined
    
    interface isT<T> {
      (v: never): '0';
      (v: T): '1';
      (v: any): '0';
    }
    type Matches<V, T> = isT<T>(V);
    type isBool = isT<boolean>;
    let falseBool: isBool(false); // 1
                          ~~~~~
!!! error TS2345: Argument of type 'false' is not assignable to parameter of type 'never'.
    let trueBool: isBool(true); // 1
                         ~~~~
!!! error TS2345: Argument of type 'true' is not assignable to parameter of type 'never'.
    let strBool: isBool(string); // 0
                        ~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'boolean'.
                        ~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'never'.
    let anyBool: isBool(any); // 0
                        ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'boolean'.
                        ~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'never'.
    let neverBool: isBool(never); // 0
    
    type Assert<T> = {
                     ~
      (v: null | undefined): never;
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      <U>(v: U): U;
    ~~~~~~~~~~~~~~~
    }(T);
    ~~~~
!!! error TS2345: Argument of type 'string | undefined' is not assignable to parameter of type 'null | undefined'.
!!! error TS2345:   Type 'string' is not assignable to type 'null | undefined'.
    let assert: Assert<string | undefined>; // string
    
    type Minus<A, B> = {
                       ~
      (v: B): never;
    ~~~~~~~~~~~~~~~~
      <U>(v: U): U;
    ~~~~~~~~~~~~~~~
    }(A);
    ~~~~
!!! error TS2345: Argument of type 'string | number' is not assignable to parameter of type 'number'.
!!! error TS2345:   Type 'string' is not assignable to type 'number'.
    let noNumbers: Minus<string | number, number>; // string
    
    interface UnwrapPromise {
      <U>(v: PromiseLike<U>): UnwrapPromise(U);
                              ~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'PromiseLike<{}>'.
                              ~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type '{}' is not assignable to parameter of type 'PromiseLike<{}>'.
!!! error TS2345:   Property 'then' is missing in type '{}'.
      <U>(v: U): U;
    };
    declare const testUnwrap1: UnwrapPromise(string);
                                             ~~~~~~
!!! error TS2345: Argument of type 'string' is not assignable to parameter of type 'PromiseLike<{}>'.
    declare const testUnwrap2: UnwrapPromise(Promise<string>);
    declare const testUnwrap3: UnwrapPromise(boolean | Promise<string>);
                                             ~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'boolean | Promise<string>' is not assignable to parameter of type 'PromiseLike<string>'.
!!! error TS2345:   Type 'true' is not assignable to type 'PromiseLike<string>'.
    declare function myThen<T, TResult1 = T, TResult2 = never>(
            prom: Promise<T>,
            onfulfilled?: ((value: T) => TResult1) | undefined | null, 
            onrejected?: ((reason: any) => TResult2) | undefined | null
        ): Promise<UnwrapPromise(TResult1) | UnwrapPromise(TResult2)>;
                                             ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'number | Promise<boolean>' is not assignable to parameter of type 'PromiseLike<boolean>'.
!!! error TS2345:   Type 'number' is not assignable to type 'PromiseLike<boolean>'.
    declare const pr: Promise<number>;
    declare function f(x: number): Promise<string>;
    declare function g(x: number): number | Promise<boolean>;
    const testThen = myThen(pr, f, g);
    
    interface Promise<T> {
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1) | undefined | null, 
            onrejected?: ((reason: any) => TResult2) | undefined | null
        ): Promise<UnwrapPromise(TResult1) | UnwrapPromise(TResult2)>;
                   ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'PromiseLike<{}>'.
                   ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'number | Promise<string>' is not assignable to parameter of type 'PromiseLike<string>'.
!!! error TS2345:   Type 'number' is not assignable to type 'PromiseLike<string>'.
                                             ~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type 'any' is not assignable to parameter of type 'PromiseLike<{}>'.
    }
    // prevents error: Argument of type '(x: number) => number | Promise<string>' is not assignable to parameter of type '(value: number) => string | PromiseLike<string>';
    const tryProm = pr.then((x: number) => { 
        if (x < 0) return f(x);
        return x;
    });
    
    interface ObjectHasStringIndex {
      // <T extends { [k: string]: any }>(o: T): T[string];
      (o: { [k: string]: any }): '1';
      (o: {}): '0';
    }
    let ObjectHasStringIndexTestT: ObjectHasStringIndex({ [k: string]: 123 }); // '1'
    let ObjectHasStringIndexTestF: ObjectHasStringIndex({ a: 123 }); // wanted '0', got '1'... so can't match for index, and erroring RHS yields `any`. ouch.
    
    type IndexCall<T extends () => { [k: string]: any }, K extends keyof (T())> = T()[K];
    type CallMember<T extends { [k: string]: () => any }, K extends keyof T> = T[K]();
    type MappedMemberCall<T extends { [k: string]: () => any }> = { [K in keyof T]: T[K]() };
    
    type HasKey<T, Key extends string> = (
      { [K in keyof T]: 'true' } &
      { [key: string]: 'false' }
    )[Key];
    
    type HasKindKey<T extends () => any> = HasKey<T(), 'kind'>;
    type MapHasKey<T extends { [k: string]: () => any }, Key extends string> = {
        [K in keyof T]: HasKey<T[K](), Key>
    };
    
    type KeyOfCall<T extends () => any> = keyof (T());
    
    type Strip1<T extends () => any> = { [K in keyof (T())]: T()[K] };
    type Strip2<T extends () => { [k: string]: () => any }> = { [K in keyof (T())]: T()[K]() };
    
    type Obj = {
        x: () => number,
        z: () => { kind: 'Just', value: string }
    }
    
    type T1 = (() => number)();
    type T7 = CallMember<Obj, 'x'>;
    type T8 = IndexCall<() => Obj, 'x'>;
    type T9 = MappedMemberCall<Obj>; // fails, unresolved, want { x: number, z: { kind: 'Just', value: string } }
    type T13 = keyof (() => Obj)();
    type T14 = KeyOfCall<() => Obj>;
    type T15 = Obj['z']()['kind'];
    type T16 = MapHasKey<Obj, 'kind'>; // fails, unresolved, want { x: 'false', z: 'true' }
    type T17 = Strip1<() => Obj>; // fails, unresolved, want { x: () => number, z: () => { kind: 'Just', value: string } }
    type T19 = Strip2<() => Obj>; // fails, unresolved, want { x: number, z: { kind: 'Just', value: string } }
    
    let a1: () => string;
    let b1: typeof a1();
    type Abc<T extends () => any> = T();
    let c1: Abc<typeof a1>;
    
    declare function infer1<T extends () => any>(x: T): T();
    infer1(null! as () => number);
    
    declare function infer2<T extends () => any>(x: { a: T }): T();
    infer2(null! as { a: () => number });
    
    declare function infer3<T>(x: { a: () => T }): T;
    infer3(null! as { a: () => number });
    const res3: number = infer3(null! as { a: () => number });
    
    declare function infer4<T>(x: T, y: () => T): void;
    infer4(5, () => 5);
    
    function assignability<T>(x: T, y: () => T) {
        const a: T = x;
        const b: T = y();
    }
    
    // function mappedAssignability<T>(x: T, y: CallMember<T>) {
    //     const d: T() = y;
    // }
    
    // function mappedComparability<T>(x: T, y: CallMember<T>) {
    //     x === x;
    //     y === y;
    //     x === y;
    // }
    
    // type IdMapped<T> = { [K in keyof T]: T[K] }
    
    // function mappedRelations<T>(x: IdMapped<T>, y: Partial<T>, z: CallMember<T>) {
    //     x === z;
    //     y === z;
    
    //     const a: IdMapped<T> = z;
    //     const b: Partial<T> = z;
    // }
    
    // mappedRelations(null! as Obj, null! as Partial<Obj>, null! as CallMember<Obj>);
    // mappedRelations(null! as CallMember<Obj>, null! as CallMember<Obj>, null! as CallMember<Obj>);
    